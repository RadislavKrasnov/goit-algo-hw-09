### Test results and Algorithms Complexity
```
{50: 2, 10: 1, 2: 1, 1: 1}
{1: 1, 2: 1, 10: 1, 50: 2}
find_min_coins time execution for cost 113 is 0.00019058699945162516
find_coins_greedy time execution for cost 113 is 2.236299951619003e-05

find_min_coins time execution for cost 521 is 0.0008097160007309867
find_coins_greedy time execution for cost 521 is 4.306000846554525e-06

find_min_coins time execution for cost 995 is 0.0014681929988000775
find_coins_greedy time execution for cost 995 is 4.113999239052646e-06
```
```
Algorithm           | Time complexity | Space Complexity
find_min_coins      | O(Value)        | O(Value)
find_coins_greedy   | O(Value)        | O(Value)
```

### Conclusion
Реалізовано два алгортими, які знаходять мінімальну кількість монет, з яких  
складається задана сума. Алгоритми виконують задачу у два різні способи,  
за допомогою динамічного програмування та жадібного алгоритму.  
Алгоритм динамічного програмування реалізовано за допомогою підходу TOP DOWN з  
мемоїзацією.  
За показниками часу виконання алгоритм динамічного програмування працює більш ефективно,  
але у цього алгоритму є суттєвий недолік - великі суми перевищюють максимальну кількість  
рекурсивних викликів. При сумі 1000 випадає помилка рекурсії. Тому при використанні  
алгоритму динамічного програмування можна спробувати використаи підхід Bottom Up, який  
реалізується ітеративно. Потенційно це може бути кращє за жадібний алгоритм, але це потребує перевірки.  
Щодо жадібного алгоритму, то на великих значєннях він працює значно повільніше,   
але через ітеративний підхід може оброблювати великі сумми.  

За теоретичною оцінкою, то вони однакові по складності, так як час виконання O(Value) залежить від заданої суми,  
з урахуванням того що кількість номіналів монет завжди однакова.  
Так само просторова складність O(Value) залежить від кількості збережених занчень для конкретної заданої суми.  

Отже, за рахунок того, що динамічне програмування з підходом TOP DOWN використовує мемоїзацію, час виконання  
обрахунків зменшується. Але недоліком може бути обмеженість стеку викликів. Динамічне програмування підходить,  
колм ми маємо розділити велику задачу на підзадачі і ці підзадачі дублюються. Тоді можна зберігати проміжні результати.  
це пришвдшуе виконання, але потребує більшої пам'яті.  
Жадібні алгоритми, більш ефективні при знаходжені локального оптимального рішення. Ці алгоритми самі по собі швидкі,  
вле через необхідність постійного обчислення значень можуть займати більше часу ніж з динамічним програмуванням.  
Хоча потенційно можуть займати менше пам'яті при виконанні, через те, що не зберігають проміжних результатів.  
Тобто, якщо наша задача має повторівані підзадачі, і кожа підзадача веде до оптимального рішення в цілому,  
то використовуємо динамічне програмування.  
Якщо задача потребує послідовного та постійного обчислення оптимального рішення на кожному кроці, то такі підзадачі  
потрібно вирішувати за допомогою  
жадібних алгоритмів.  
